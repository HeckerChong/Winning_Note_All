{"./":{"url":"./","title":"说明","keywords":"","body":"Winning技能手册 个人针对技术手册行整理汇总 如有侵权请联系站主，立即删除 "},"Winning_Kill_One/技术手册第一册.html":{"url":"Winning_Kill_One/技术手册第一册.html","title":"技术手册第一册","keywords":"","body":"技术手册第一册 主要讲的SQL方面的知识"},"Winning_Kill_One/第一篇SQL常用命令的使用.html":{"url":"Winning_Kill_One/第一篇SQL常用命令的使用.html","title":"第一篇 SQL常用命令的使用","keywords":"","body":""},"Winning_Kill_One/第一节四条常用命令.html":{"url":"Winning_Kill_One/第一节四条常用命令.html","title":"第一节 四条常用命令","keywords":"","body":""},"Winning_Kill_One/SELECT.html":{"url":"Winning_Kill_One/SELECT.html","title":"SELECT","keywords":"","body":"一、SELECT 命令 SELECT语句的完整语法较复杂，但是其主要的子句可归纳如下： SELECT [DISTINCT] [TOP n] select_list [INTO new_table_name] FROM table_list [WHERE search_conditions] [GROUP BY [ALL] group_by_list] [HAVING search_conditions] [ORDER BY order_list [ASC | DESC] ] 1、select_list描述结果集的列。它是一个逗号分隔的表达式列表。每个表达式同时定义格式（数据类型和大小）和结果集列的数据来源。每个选择列表表达式通常是对从中获取数据的源表或视图的列的引用，但也可能是其它表达式，例如常量或Transact-SQL函数。在选择列表中使用*表达式指定返回源表中的所有列。 select hzxm,zje-yhje zje,substring(jsrq,1,8) rq , case when jszt=1 then ”中途结帐” else “出院结帐” end 类型,* from ZY_BRJSK where jsrq between ‘20200101’ and ‘2020011024’ and ybjszt=2 and jlzt in (0,1,2) 2、在系统中，可能有多个对象带有相同的名称。例如，ZY_BRJSK和ZY_BRSYK都指定了syxh等列。若要解析多义性并且指定syxh为ZY_BRJSK所有，请至少使用用户ID限定表的名称，如：ZY_BRJSK.syxh。 或者使用别名，如table_name AS table alias和table_name table_alias 如： select a.* from ZY_BRSYK as a,ZY_BRJSK b where a.syxh=b.syxh and b.jsrq between ‘20200101’ and ‘2020011024’ and ybjszt=2 and jlzt in (0,1,2) 3、以 @local_variable = expression形式的变量赋值，如果SELECT语句返回多个值，则将返回的最后一个值赋给变量。如果SELECT语句没有返回行，变量将保留当前值。 declare @syxh int select @syxh=syxh from ZY_BRJSK where xh=@xh 4、DISTINCT 关键字可从结果集中除去重复的行。 select ksdm,count(distinct blh) rs from VW_MZBRJSK where sfrq between '20201201' and '2020121024' and ybjszt=2 and jlzt in (0,1,2) group by ksdm 5、TOP关键字指定返回结果集的前n行。TOP n [PERCENT]，返回前n%的记录 select top 10 ghdwmc 供货单位,sum(jjje) as 进价金额 from YK_YPRKZD where jzrq between '20200101' and '2020011024' and jzbz in (1,2) and gzbz=0 group by ghdwmc order by 进价金额 desc Tips:如果查询包含 ORDER BY 子句，将输出由 ORDER BY 子句排序的前 n 行（或前百分之 n 行） 6、INTO new_table_name指定使用结果集来创建新表。new_table_name指定新表的名称。创建一个使用IDENTITY属性的新列(select into)，注意列名的4种写法 select identity(int,100,1) as 序号,blh \"病历号\",hzxm 病人姓名,性别=sex into #temp from ZY_BRSYK where ryrq between '20200220' and '2020022124' 7、From:指定在DELETE、SELECT和UPDATE语句中使用的表、视图、派生表和连接表。 如果表或视图存在于同一服务器的其它数据库中，应按格式database.owner.object_name如果表或视图存在于本地服务器之外的一台链接的服务器上，应按以下格式使用由四部分组成的名称：linked_servername.database.owner.object_name 与其他服务器的连接：sp_addlinkedserver其他服务器名。 视图提示只能用在 SELECT 语句中，而不能用于UPDATE、DELETE或INSERT语句。 where中left join,right join的使用 8、WHERE子句是一个筛选，它定义了源表中的行要满足SELECT语句的要求所必须达到的条件。只有符合条件的行才向结果集提供数据。不符合条件的行中的数据不会被使用。 Between...and where zje between 0 and 500[0,500]等同于zje>=0andzje 500or 常用子查询的语句 WHERE expression [NOT] IN (subquery) WHERE [NOT] EXISTS (subquery) select * from ZY_BRJSK where jsrq between '20201201' and '2020121024' and ybjszt=2 and jlzt in (0,1,2) and ybdm in (select ybdm from YY_YBFLK where pzlx='12') 或者 select * from ZY_BRJSK a where jsrq between '20201201' and '2020121024' and ybjszt=2 and jlzt in (0,1,2) and exists (select 1 from YY_YBFLK b where a.ybdm=b.ybdm and pzlx='12') Like/not like ,通配符：%、_、[ ]、 select * from YK_YPRKZD where rkrq like '20200101%' 9、GROUP BY子句和ALL关键字 只有在SELECT语句还包括WHERE子句时，ALL关键字才有意义。 列出所有进过货的单位： select ghdwmc 供货单位,sum(jjje) as 进价金额 from YK_YPRKZD where jzrq between '20200101' and '2020011024' and jzbz in (1,2) and gzbz=0 group by all ghdwmc 列出满足条件的单位： select ghdwmc 供货单位,sum(jjje) as 进价金额 from YK_YPRKZD where jzrq between '20200101' and '2020011024' and jzbz in (1,2) and gzbz=0 group by ghdwmc 10、使用HAVING子句选择行WHERE子句用来筛选FROM子句中指定的操作所产生的行。GROUP BY子句用来分组WHERE子句的输出。HAVING子句从中间结果集对行进行筛选。 带聚合函数的HAVING子句: select hzxm,sum(zje) from ZY_BRJSK where jsrq between '20200101' and '2020011024' and ybjszt=2 and jlzt in (0,1,2) group by hzxm having sum(zje)>10000 不带聚合函数的HAVING子句: SELECT hzxm FROM ZY_BRJSK where jsrq between '20200101' and '2020011024' and ybjszt=2 and jlzt in (0,1,2) GROUP BY hzxm HAVING hzxm LIKE '张%' 11、order by...[ ASC | DESC ]对结果集排序。 ASC 和 DESC 关键字用于指定行是按升序还是按降序排序。使用UNION时，只能对最后结果排序。 12、UNION运算符使您得以将两个或多个SELECT语句的结果组合成一个结果集。使用UNION组合的结果集都必须具有相同的结构。而且它们的列数必须相同，并且相应的结果集列的数据类型必须兼容。UNION运算符从结果集中删除重复的行。如果使用ALL关键字，那么结果中将包含所有行并且将不删除重复的行。 select hzxm,sum(zje) zje from ZY_BRJSK where jsrq between '20201201' and '2020121024' and ybjszt=2 and jlzt in (0,1,2) group by hzxm union select '合计',sum(zje) from ZY_BRJSK where jsrq between '20201210' and '2020121024' and ybjszt=2 and jlzt in (0,1,2) order by sum(zje) "},"Winning_Kill_One/DELETE.html":{"url":"Winning_Kill_One/DELETE.html","title":"DELETE","keywords":"","body":"二、DELETE 命令 DELETE table_or_view [FROM table_sources ] [WHERE search_condition ] 1、删除全部行 Delete #temp = TRUNCATE TABLE #temp 如果要删除在表中的所有行，则TRUNCATE TABLE比DELETE快。DELETE以物理方式一次删除一行，并在事务日志中记录每个删除的行。TRUNCATE TABLE则释放所有与表关联的页。因此，TRUNCATE TABLE比DELETE快且需要的事务日志空间更少。 [warning] Tips:注意drop table 与delete 的区别 2、在行集上使用delete delete from #temp where... 3.在游标的当前行上使用DELETE 下例显示在名为cs_dxmdm的游标上所做的删除。它只影响当前从游标提取的单行。 DELETE FROM #dxmdm WHERE CURRENT OF cs_dxmdm 4、据与关联表、子查询上使用delete delete ZY_BRSYK from ZY_BRSYK a,ZYB_BRYJK b where a.syxh=b.syxh and a.brzt=9 "},"Winning_Kill_One/UPDATE.html":{"url":"Winning_Kill_One/UPDATE.html","title":"UPDATE","keywords":"","body":"三、UPDATE 命令 update table_name set 列=表达式 [FROM table_sources] [WHERE search_condition] 1、使用简单的update UPDATE YF_YFZKC SET djsl = 0 2、 把WHERE子句和UPDATE语句一起使用 UPDATE YF_YFZKC SET jxje=0 Where abs(jxje)>1000000 3、通过UPDATE语句使用来自另一个表的信息 update #temp set ksmc =b.name from #temp a,YY_KSBMK b where a.ksdm=b.id 4、在游标的当前行上使用update update #dxmdm set zje=@zje where CURRENT OF cs_dxmdm "},"Winning_Kill_One/INSERT.html":{"url":"Winning_Kill_One/INSERT.html","title":"INSERT","keywords":"","body":"四、INSERT 命令(表必须存在) 所提供的数据值必须与列的列表匹配。数据值的数目必须与列数相同，每个数据值的数据类型、精度和小数位数也必须与相应的列匹配。 1、使用INSERT...SELECT插入多行 insert #mzybtemp (hzxm,pzh,jzks,jzrq,jzcs,zje,ybdm,sjh,zzbz,sfzh,zddm,bjqk) select hzxm,convert(varchar(17),substring(cardno,1,10)),ksdm, substring(sfrq,1,8),1,zje-zfyje-yhje,ybdm,sjh,substring(zhbz,1,1), substring(sfzh,1,18),zddm,substring(zhbz,2,1) from VW_MZBRJSK a (nolock) where sfrq between @ksrq and @jssj and ybjszt=2 and ghsfbz in (0,1) and substring(zhbz,4,1)='0' and substring(zhbz,12,1)='0' and exists(select 1 from YY_YBFLK b (nolock) where b.ybdm=a.ybdm and b.pzlx=10) 2、使用INSERT...VALUES插入一行。 如果没有指定列的列表，指定值的顺序必须与表或视图中的列顺序一致。 insert into #temp(syxh,jsxh) values (@syxh,@jsxh) 3、SET IDENTITY_INSERT 表 ON|OFF 是否允许将显式值插入表的标识列中。如果插入值大于表的当前标识值，则SQL Server自动将新插入值作为当前标识值使用。 CREATE TABLE products (id int IDENTITY PRIMARY KEY, product varchar(40)) GO -- Inserting values into products table. INSERT INTO products (product) VALUES ('screwdriver') INSERT INTO products (product) VALUES ('hammer') INSERT INTO products (product) VALUES ('saw') INSERT INTO products (product) VALUES ('shovel') GO --删除第三行 DELETE products WHERE product = 'saw' GO -- 试图插入id=3的记录,将报错 INSERT INTO products (id, product) VALUES(3, 'garden shovel') GO -- SET IDENTITY_INSERT to ON时,能插入id=3的记录. SET IDENTITY_INSERT products ON GO INSERT INTO products (id, product) VALUES(3, 'garden shovel'). GO SET IDENTITY_INSERT products OFF GO "},"Winning_Kill_One/第二节函数.html":{"url":"Winning_Kill_One/第二节函数.html","title":"第二节 函数","keywords":"","body":""},"Winning_Kill_One/聚合函数.html":{"url":"Winning_Kill_One/聚合函数.html","title":"聚合函数","keywords":"","body":"一、聚合函数 SUM、AVG、COUNT、MAX 和 MIN 忽略空值，而 COUNT(*) 不忽略。 1、count() COUNT(*) 返回组中项目的数量。它对每行分别进行计数，包括含有空值null的行。 COUNT(ALL expression)=count(expression) 对组中的每一行都计算 *expression并返回非空值的数量。 COUNT(DISTINCT expression) 对组中的每一行都计算expression并返回唯一非空值的数量。 select count(*) 总行数, count(zlf_pt) 有值的行数, count(all zlf_pt) 有值的行数, count(distinct zlf_pt) 不重复的行数 from YY_KSBMK 总行数 有值的行数 有值的行数 不重复的行数 205 61 61 3 2、sum() sum(ALL expression)=sum(expression) 所有的非空的值求和 sum(DISTINCT expression) 返回唯一非空值的和 create table #temp (aa int,bb money) insert #temp values(1,null) insert #temp values(2,2) insert #temp values(3,2) insert #temp values(4,3) select sum(bb) a,sum(all bb) b,sum(distinct bb) c from #temp a b c 7.0000 7.0000 5.0000 3、avg() avg(ALL expression)=avg(expression) 对所有的非空的值求平均值 avg(DISTINCT expression) 返回唯一非空值的平均值 create table #temp(aa int) insert #temp values (null) insert #temp values (20) insert #temp values (30) insert #temp values (30) select avg(aa) from #temp --26 select avg(distinct aa) from #temp --25 4、 max()、min() max() 求最大值 min() 求最小值 "},"Winning_Kill_One/系统函数.html":{"url":"Winning_Kill_One/系统函数.html","title":"系统函数","keywords":"","body":"二、系统函数 1、@@IDENTITY [info] @@IDENTITY中包含此语句产生的最后的标识值。若此语句没有影响任何有标识列的表，则 @@IDENTITY返回NULL。若插入了多个行，则会产生多个标识值，@@IDENTITY返回最后产生的标识值。 insert into SF_MZCFK(jssjh, hjxh, czyh, lrrq, patid, hzxm, ybdm, zje,zfyje,yhje,zfje) select @sjh, @hjxh, @czyh, @now, patid, hzxm, @ybdm, @zjecf,@zfyjecf,@yhjecf,@zfje from #brxxk if @@error<>0 or @@rowcount=0 begin select \"保存收费处方出错！\" return end select @xhtemp=@@identity insert into SF_CFMXK(cfxh, cd_idm, gg_idm, dxmdm, ypmc, ypdm, ypdw, dwxs, ykxs, ypfj, ylsj, ypsl, ts, cfts, zfdj, yhdj) select @xhtemp, idm, gg_idm, dxmdm, ypmc, xxmdm, ypdw, dwxs, ykxs,ypfj, ylsj,fysl, 1, cfts, zfdj, yhdj from #sfmx where cfxh=@cfxh if @@error<>0 begin select \"保存收费处方明细出错！\" return end 2、@@ERROR [info] Transact-SQL语句的执行时，如果语句执行成功，则 @@ERROR 设置为 0。若出现一个错误，则返回一条错误信息。@@ERROR 返回此错误信息代码，直到另一条Transact-SQL 语句被执行。 update SF_MZCFK set jlzt=0, lrrq=(case when @jsrq='' then @now else @jsrq end), czyh=@czyh where jssjh=@sjh if @@error<>0 begin select \"更新门诊处方信息出错！\" return end 3、@@ROWCOUNT [info] 返回受上一语句影响的行数, 直到另一条Transact-SQL语句被执行。 任何不返回行的语句将这一变量设置为 0 。 select @pzlx=pzlx from YY_YBFLK (nolock) where ybdm=@ybdm if @@rowcount=0 or @@error<>0 begin select \"患者费用类别不正确！\" return end 4、CAST 和 CONVERT [info] 将某种数据类型的表达式显式转换为另一种数据类型。CAST 和 CONVERT 提供相似的功能。 CAST (expression AS data_type) CONVERT (data_type[(length)], expression [, style]) "},"Winning_Kill_One/游标函数.html":{"url":"Winning_Kill_One/游标函数.html","title":"游标函数","keywords":"","body":"三、游标函数 @@FETCH_STATUS [info] @@FETCH_STATUS返回被 FETCH 语句执行的最后游标的状态，而不是任何当前被连接打开的游标的状态。0表示FETCH 语句成功。 declare @sqlstr varchar(8000), @sqlstr4 varchar(8000), @sqlsum varchar(8000), @sqltitle varchar(8000), @dxmdm ut_kmdm, @dxmmc ut_mc16 declare cs_sfdxm cursor for select id,name from YY_SFDXMK for read only select @sqlstr='create table #temp(ksdm ut_ksdm not null,ksmc ut_mc32 not null,' select @sqltitle='',@sqlstr4='',@sqlsum='' open cs_sfdxm fetch cs_sfdxm into @dxmdm,@dxmmc while @@fetch_status=0 begin select @sqlstr=@sqlstr+'id'+@dxmdm+' numeric(14,2) default 0,' select @sqlstr4=@sqlstr4+'id'+@dxmdm+'+' select @sqltitle=@sqltitle+'id'+@dxmdm+' \"'+@dxmmc+'\",' select @sqlsum=@sqlsum+'sum(id'+@dxmdm+'),' fetch cs_sfdxm into @dxmdm,@dxmmc end close cs_sfdxm deallocate cs_sfdxm "},"Winning_Kill_One/日期时间函数.html":{"url":"Winning_Kill_One/日期时间函数.html","title":"日期时间函数","keywords":"","body":"四、日期时间函数 1、getdate() 返回当前系统日期和时间 select convert(char(30),getdate(),102) 2005.02.28 select convert(char(30),getdate(),111) 2005/02/28 select convert(char(30),getdate(),112) 20050228 select convert(char(30),getdate(),120) 2005-02-28 21:44:36 select convert(char(30),getdate(),108) 20:45:23 2、DATEADD(datepart,number,date) 在日期中添加或减去指定的时间间隔 select dateadd(day,5,'20050110') 2005-01-15 00:00:00.000 3、DATEDIFF(datepart,startdate,enddate) 返回两个日期之间的时间 select datediff(day,'20050102','20050110') --8 "},"Winning_Kill_One/数学函数.html":{"url":"Winning_Kill_One/数学函数.html","title":"数学函数","keywords":"","body":"五、数学函数 ROUND 函数用于把数值字段舍入为指定的小数位数 ABS 取绝对值 SELECT ROUND(150.75, 0) --151.00 SELECT ROUND(150.75, 0, 1) --150.00 最后的1(即非0将截断表达式) SELECT ABS(-23.23) --23.23 "},"Winning_Kill_One/字符串函数.html":{"url":"Winning_Kill_One/字符串函数.html","title":"字符串函数","keywords":"","body":"六、字符串函数 1、SUBSTRING ( expression , start , length) select substring(sfrq,1,4)+'年'+substring(sfrq,5,2)+'月'+substring(sfrq,7,2)+'日' from VW_MZBRJSK where sfrq between '20200101' and '2020010124' and ybjszt=2 and jlzt in (0,1,2) 2、LEFT ( character_expression , integer_expression )、RIGHT ( character_expression , integer_expression ) 左边、右边第一个字符开始截取字符串多少位 LEFT ( character_expression , integer_expression )=substring(character_expression ,1, integer_expression ) 3、LTRIM、RTRIM 去除左右空格 select LTRIM(' ABC') --'ABC' select RTRIM('ABC ') --'ABC' 4、LEN返回给定字符串表达式的字符（而不是字节）个数，其中不包含尾随空格。 select LEN(hzxm), datalength(RTRIM(hzxm)),hzxm from ZY_BRSYK len datalength hzxm 2 4 吴莹 3 6 周长生 3 6 蔡丽君 2 4 钱慧 5、CHARINDEX ( expression1 , expression2) 返回字符串中指定表达式的起始位置, 如果在 expression2 内没有找到 expression1，则 CHARINDEX 返回 0。 select a.sjh,a.blh,b.ysdm,a.ybdm,a.zje from VW_MZBRJSK a(nolock) where a.sfrq between @ksrq and @jsrq+'24' and a.ybjszt=2 and exists(select 1 from YY_YBBBK b where charindex('\"'+rtrim(a.ybdm)+'\"',b.ybdmjh)>0 and b.id = '31') [warning] Tips: PATINDEX 与 CHARINDEX 功能相似 PATINDEX 支持正则表达式 6、REPLACE(string_expression1,string_expression2,string_expression3) 将第一个字符串表达式中,第二个给定字符串表达式的所有实例,都替换为第三个表达式 SELECT REPLACE('2020-10-30','-','') --20201030 "},"Winning_Kill_One/转换函数.html":{"url":"Winning_Kill_One/转换函数.html","title":"转换函数","keywords":"","body":"七、转换函数 CONVERT(data_type(length),data_to_be_converted,style) CAST(expression AS data_type) FORMAT(column_name,format) 示例： 数据类型的转换 --将varchar转换为numeric DECLARE @i varchar(10) SET @i='12' --使用CONVERT SELECT CONVERT(numeric(9,2),@i) --12.00 --使用CAST SELECT CAST(@i AS numeric(9,2)) --12.00 日期格式的转换 --转换为 yyyymmdd SELECT GETDATE() --2020-10-30 18:00:01.547 --使用CONVERT SELECT CONVERT(VARCHAR(10),GETDATE(),112) --20201030 --使用CAST SELECT CAST(GETDATE() AS VARCHAR(20)) --10 30 2020 6:00PM --在SQL Server2012开始有一个格式化的函数，支持datetime数据类型的样式格式化 SELECT FORMAT(GETDATE(),'yyyyMMdd') --20201030 --结合多个函数将datetime格式，转换为HIS常见的日期格式 SELECT SUBSTRING(REPLACE(CONVERT(VARCHAR(20),GETDATE(),120),'-',''),1,8)+RIGHT(CONVERT(VARCHAR(20),GETDATE(),120),8) [info] Tips CONVERT() 的第三个参数是可选，CAST() 在转换日期格式的时候只能默认转换为一种，没有提供日期样式的参数。 HIS 里面 yyyyMMddHH:mm:ss 这个格式并不是SQL Server指定的一种日期格式 "},"Winning_Kill_One/第三节SET.html":{"url":"Winning_Kill_One/第三节SET.html","title":"第三节 SET","keywords":"","body":""},"Winning_Kill_One/SET.html":{"url":"Winning_Kill_One/SET.html","title":"SET","keywords":"","body":"1、SET IDENTITY_INSERT table_name ON | OFF [info] 允许将显式值插入表的标识列中。 2、SET NOCOUNT SET NOCOUNT ON 不返回计数（表示受 Transact-SQL 语句影响的行数） SET NOCOUNT OFF 返回计数。 3、SET ROWCOUNT { number | @number_var } [info] 在返回指定的行数之后停止处理查询。若要关闭该选项（以便返回所有的行），请将 SET ROWCOUNT 指定为 0，否则直到遇到 SET ROWCOUNT 命令为止。 如果行数的值较小，则 SET ROWCOUNT 替代 SELECT 语句 TOP 关键字。 "},"Winning_Kill_One/第四节控制流语句.html":{"url":"Winning_Kill_One/第四节控制流语句.html","title":"第四节 控制流语句","keywords":"","body":""},"Winning_Kill_One/流程控制语句.html":{"url":"Winning_Kill_One/流程控制语句.html","title":"流程控制语句","keywords":"","body":"1、 BEGIN 和 END 定义一系列一起执行的 Transact-SQL 语句。 begin select * from GH_GHZDK WHERE ghrq LIKE '20201027%' end 2、IF...ELSE IF (条件表达式) 语句块 ELSE 语句块 [warning] Tips:如果在 IF...ELSE 块的 IF 区和 ELSE 区都使用了 CREATE TABLE 语句或 SELECT INTO 语句，那么 CREATE TABLE 语句或 SELECT INTO 语句不能指向相同的表名。 3、GOTO 将执行流变更到标签处。跳过 GOTO 之后的 Transact-SQL 语句，在标签处继续处理。GOTO 语句和标签可在过程、批处理或语句块中的任何位置使用。GOTO 语句可嵌套使用。不论是否使用 GOTO 语句，标签均可作为注释方法使用。 定义标签： label : 改变执行： GOTO label 4、WHILE WHILE(条件) BEGIN ... BREAK ... CONTINUE ... END [info] 只要指定的条件为真，就重复执行语句。 可以使用 BREAK 和 CONTINUE 关键字或其他改变表达式值的方法在循环内部控制 WHILE 循环中语句的执行。 5、CASE…WHEN…THEN select sum(case when jlzt in(0,1) then 1 when jlzt in (2) then -1 else 0 end) 交易笔数 from VW_MZBRJSK where sfrq between @ksrq and @jsrq+'24' and ybjszt=2 and jlzt in (0,1,2) 或: select sum(case jlzt when 0 then 1 when 2 then 1 when 1 then -1 else 0 end) 结算笔数 from ZY_BRJSK where jsrq between '20201201' and '2020030124' and ybjszt=2 and jlzt in (0,1,2) 扩展：IIF 语句(SQL2012才开始支持) IIF ( 条件, true,false) 类似于编程语言中的三元运算符，可以与case...when语句转换 select sum(IIF(jlzt=1,-1,1)) 结算笔数 from SF_BRJSK where jsrq between '20201201' and '2020030124' and ybjszt=2 and jlzt in (0,1,2) 6、注释 单行: -- 多行:/.../ 7、DECLARE @local_variable 在批处理或过程的正文中用 DECLARE 语句声明变量，并用 SET 或 SELECT 语句给其赋值。游标变量可通过该语句声明，并且可用在其它与游标相关的语句中。所有变量在声明后均初始化为 NULL。 DECLARE @Variablename varchar(50) @Variablename是声明的变量名，varchar(50)是变量名的数据类型 DECLARE语句可以一次声明多个变量 例： Declare @ksrq ut_rq8,@jsrq ut_rq8 Declare cs_dxmdm cursor for select id,name from YY_SFDXMK 8、execute或exec 执行用户定义函数、系统过程、用户定义存储过程或扩展存储过程。 在执行存储过程时，如果语句是批处理中的第一个语句，则不一定要指定 EXECUTE 关键字。 exec usp_sf_bb_kssrtj '20200101','20200131' declare @errmsg varchar(50) exec usp_yy_gxtz 1, 0, '4001', 0, '200110', @errmsg output exec('drop table '+@@tablename+')' "},"Winning_Kill_One/第五节常用的存储过程.html":{"url":"Winning_Kill_One/第五节常用的存储过程.html","title":"第五节 常用的存储过程","keywords":"","body":""},"Winning_Kill_One/常用的系统存储过程.html":{"url":"Winning_Kill_One/常用的系统存储过程.html","title":"常用的系统存储过程","keywords":"","body":"1、sp_who 提供关于当前 Microsoft® SQL Server™ 用户和进程的信息。 列 数据类型 描述 spid smallint 系统进程 ID。 ecid smallint 与指定 SPID 相关联的给定线程的执行上下文 ID。 ECID = {0, 1, 2, 3, ...n}，其中 0 始终表示主或父线程，并且 {1, 2, 3, ...n} 表示子线程。 status nchar(30) 进程状态。 dormant： SQL Server正在重置会话。running： 会话正在运行一个或多个批处理。 background： 会话正在运行后台任务，例如死锁检测。 rollback: 会话正在进行事务回滚。 pending： 会话正在等待辅助线程可用。 runnable: 在等待获取时间段时，会话的任务在调度程序的可运行队列中。 spinloop: 会话的任务正在等待自旋锁释放。 suspended: 会话正在等待事件（例如I / O）完成。 loginame nchar(128) 与特定进程相关联的登录名。 hostname nchar(128) 每个进程的主机或计算机名。 blk char(5) 如果存在阻塞进程，则是该阻塞进程的系统进程 ID。否则该列为零。 dbname nchar(128) 进程使用的数据库。 cmd nchar(16) 为此进程执行的 SQL Server 命令（Transact-SQL 语句、SQL Server 内部引擎处理等）。 [info] KILL 命令通常用于终止这样一些进程，它们锁住了其它重要进程，或者正在执行一个查询，而该查询正在使用必需的系统资源。 [danger] 当现场产生挂号、收费等业务缓慢或者无法进行操作，可以使用sp_who查看是否有事务死锁，可配合kill spid杀死阻塞的进程 2、sp_depends 显示有关数据库对象相关性的信息（例如，依赖表或视图的视图和过程，以及视图或过程所依赖的表和视图）。 例: 当我们想查询YY_KSBMK被哪些对象(存储过程，视图...)引用了 sp_depends YY_KSBMK 3、sp_help 报告有关数据库对象（sysobjects 表中列出的任何对象）、数据类型、用户定义数据类型的信息。 --列出表结构、索引等 sp_help YY_KSBMK --列出ut_rq8的数据类型定义 sp_help ut_rq8 4、sp_helpindex 列出对象的索引信息 --列出YY_KSBMK的索引信息 sp_helpindex YY_KSBMK 5、sp_helptext 显示规则、默认值、未加密的存储过程、用户定义函数、触发器或视图的文本。 sp_helptext usp_sf_sfcl 6、sp_password 修改登录名的密码。如果密码为空，则输入null。 sp_password 原密码,新密码,’sa’ 7、DBCC OPENTRAN DBCC OPENTRAN帮助识别可能阻止日志截断的活动事务。DBCC OPENTRAN在指定数据库的事务日志中显示有关最旧的活动事务以及最旧的分布式和非分布式复制事务的信息。仅当日志中存在活动事务或数据库包含复制信息时，才会显示结果。如果日志中没有活动的事务，则会显示参考消息。 [danger] 当发现现场挂号，收费等业务很缓慢时，可以执行OPEN OPENTRAN看看是否有活动的事务 "},"Winning_Kill_One/第六节表存储过程的创建.html":{"url":"Winning_Kill_One/第六节表存储过程的创建.html","title":"第六节 表、存储过程的创建","keywords":"","body":""},"Winning_Kill_One/表存储过程的创建.html":{"url":"Winning_Kill_One/表存储过程的创建.html","title":"表、存储过程的创建","keywords":"","body":"1、create table create table YK_YPCGZD ( xh ut_xh12 identity(1,1) not null, --序号 czyh ut_czyh not null, --操作员 cjrq ut_rq16 not null, --创建日期 djh ut_sjh null , --单据号 ksdm ut_ksdm not null, --科室代码 shry ut_czyh null , --审核员 shrq ut_rq16 null , --审核日期 jlzt ut_bz not null, --记录状态 0录入1审核2作废 jzbz ut_bz not null, --记账标志 0:录入 1：记账 memo ut_memo null , --memo constraint PK_YK_YPCGZD primary key (xh) ) go create index idx_djh on YK_YPCGZD(djh) create index idx_cjrq on YK_YPCGZD(cjrq) IDENTITY [info] 表示新列是标识列。当向表中添加新行时，自动将为该标识列提供一个唯一的、递增的值。标识列通常与 PRIMARY KEY 约束一起用作表的唯一行标识符。可以将 IDENTITY 属性指派给 tinyint、smallint、int、bigint、decimal(p,0) 或 numeric(p,0) 列。对于每个表只能创建一个标识列。不能对标识列使用绑定默认值和 DEFAULT 约束。必须同时指定种子和增量，或者二者都不指定。如果二者都未指定，则取默认值 (1,1)。 关于自定义类型的说明： execute sp_addtype ut_bz, 'smallint', null go create default D_ut_bz as 0 go execute sp_bindefault D_ut_bz, ut_bz go execute sp_addtype ut_xh12, 'numeric(12,0)','NOT NULL' go CONSTRAINT [info] 是可选关键字，表示 PRIMARY KEY、NOT NULL、UNIQUE、FOREIGN KEY 或 CHECK 约束定义的开始。约束是特殊属性，用于强制数据完整性并可以为表及其列创建索引。 PRIMARY KEY [info] 是通过唯一索引对给定的一列或多列强制实体完整性的约束。对于每个表只能创建一个 PRIMARY KEY 约束。 CLUSTERED | NONCLUSTERED [info] 是表示为 PRIMARY KEY 或 UNIQUE 约束创建聚集或非聚集索引的关键字。PRIMARY KEY 约束默认为 CLUSTERED，UNIQUE 约束默认为 NONCLUSTERED。 在 CREATE TABLE 语句中只能为一个约束指定 CLUSTERED。 2、drop table 删除表 3、创建存储过程 CREATE PROC [ EDURE ] procedure_name [ { @parameter data_type } [ = default ] [ OUTPUT ] ] [ ,...... ] AS sql_statement 创建临时存储过程 create proc #temp as select * from YY_KSBMK SQL Server 允许创建的存储过程引用尚不存在的对象。 4、alter proc 更改已存在的存储过程 5、drop proc 删除存储过程 "},"Winning_Kill_One/第二篇如何制作外挂报表.html":{"url":"Winning_Kill_One/第二篇如何制作外挂报表.html","title":"第二篇 如何制作外挂报表","keywords":"","body":""},"Winning_Kill_One/第一节编写相关的存储过程.html":{"url":"Winning_Kill_One/第一节编写相关的存储过程.html","title":"第一节 编写相关的存储过程","keywords":"","body":""},"Winning_Kill_One/存储过程的标准格式.html":{"url":"Winning_Kill_One/存储过程的标准格式.html","title":"存储过程的标准格式","keywords":"","body":"一、存储过程的标准格式 例：挂号科室统计报表 if exists(select * from sysobjects where name='usp_gh_tybb_ghkstj') drop proc usp_gh_tybb_ghkstj go create procedure usp_gh_tybb_ghkstj( @ksrq ut_rq8, @jsrq ut_rq8, @sflx ut_dm2 ) as /********** [版本号]4.0.0.0.0 [创建时间]2005.02.02 [作者]黄克华 [版权] Copyright ? 1998-2001上海金仕达-卫宁医疗信息技术有限公司 [描述] 挂号科室统计报表 [功能说明] 适合所有医院 增加参数类型“医保代码集”： select id \"代码\",name \"名称\",ybdmjh \"医保代码集\" from YY_JZMBK where xtbz = 0 and name like 参数Z001:外挂报表金额部分是否包含优惠金额 注意修改时，必须同步修改usp_gh_tybb_ghfbtj(和usp_gh_tybb_ghystj),两者的区别仅在于一个是ksdm/ksmc(和ysdm/ysmc),一个是ybdm/ybsm [参数说明] @ksrq 开始日期 @jsrq 结束日期 @sflx 收费类型(-1全部，其他：取结帐模板) [返回值] [结果集、排序] 成功：结果集 错误：\"F\",\"错误信息\" [调用的sp] exec usp_gh_tybb_ghkstj '20031201','20031210','-1' [调用实例] **********/ set nocount on ........... return go "},"Winning_Kill_One/报表书写的常见问题.html":{"url":"Winning_Kill_One/报表书写的常见问题.html","title":"报表书写的常见问题","keywords":"","body":"二、报表书写的常见问题 1）存在年表的情况，应该用视图不应该用表 [danger] 错误写法： select * from SF_BRJSK where sfrq between @ksrq and @jsrq+’24’ and ybjszt=2 and jlzt in (0,1,2) [success] 正确写法： select * from VW_MZBRJSK where sfrq between @ksrq and @jsrq+’24’ and ybjszt=2 and jlzt in (0,1,2) 2）使用聚合函数时，未包含在聚合函数中的列，必须包含再在 GROUP BY 子句中。 [danger] 错误写法： select ksdm,ysdm,sum(zje) zje from VW_MZBRJSK where sfrq between @ksrq and @jsrq+’24’ and ybjszt=2 and jlzt in (0,1,2) group by ksdm [success] 正确写法: select ksdm,ysdm,sum(zje) zje from VW_MZBRJSK where sfrq between @ksrq and @jsrq+’24’ and ybjszt=2 and jlzt in (0,1,2) group by ksdm,ysdm 3）在分支中不能多次生成临时表 [danger] 错误写法： If 取本地表 Select xh,zje Into #temp From SF_BRJSK where sfrq between @ksrq and @jsrq+’24’ and ybjszt=2 and jlzt in (0,1,2) else Select xh,zje Into #temp From SF_NBRJSK where sfrq between @ksrq and @jsrq+’24’ and ybjszt=2 and jlzt in (0,1,2) [success] 正确写法： create table #temp ( xh int, zje ut_je14) if 取本地表 Insert into #temp Select * From SF_BRJSK where sfrq between @ksrq and @jsrq+’24’ and ybjszt=2 and jlzt in (0,1,2) else insert into #temp Select * From SF_NBRJSK where sfrq between @ksrq and @jsrq+’24’ and ybjszt=2 and jlzt in (0,1,2) 4）生成的临时表，应注意数据类型 [danger] 错误写法： Select substring(sfrq,1,8) rq,sum(zje) mz_zje,0 zy_zje Into #temp From VW_MZBRJSK (nolock) where sfrq between @ksrq and @jsrq+’24’ and ybjszt=2 and jlzt in (0,1,2) group by substring(sfrq,1,8) insert into #temp Select substring(sfrq,1,8),0 mz_zje,sum(zje) zy_zje from ZY_BRJSK (nolock) where jsrq between @ksrq and @jsrq+’24’ and ybjszt=2 and jlzt in (0,1,2) group by substring(jsrq,1,8) [success] 正确写法： Select substring(sfrq,1,8) rq,sum(zje) mz_zje,convert(numeric(14,2),0) zy_zje Into #temp From VW_MZBRJSK (nolock) where sfrq between @ksrq and @jsrq+’24’ and ybjszt=2 and jlzt in (0,1,2) group by substring(sfrq,1,8) insert into #temp Select substring(sfrq,1,8),convert(numeric(14,2),0) mz_zje,sum(zje) zy_zje from ZY_BRJSK (nolock) where jsrq between @ksrq and @jsrq+’24’ and ybjszt=2 and jlzt in (0,1,2) group by substring(jsrq,1,8) 5）注意union的写法 [danger] 错误写法： insert into #temp select cardno,zje from SF_BRJSK (nolock) where sfrq between @ksrq and @jsrq+’24’ and ybjszt=2 and jlzt in (0,1,2) union select cardno,zje from SF_NBRJSK (nolock) where jsrq between @ksrq and @jsrq+’24’ and ybjszt=2 and jlzt in (0,1,2) [success] 正确写法： insert into #temp select cardno,zje from SF_BRJSK (nolock) where sfrq between @ksrq and @jsrq+’24’ and ybjszt=2 and jlzt in (0,1,2) union all select cardno,zje from SF_NBRJSK (nolock) where jsrq between @ksrq and @jsrq+’24’ and ybjszt=2 and jlzt in (0,1,2) 6）主从表不能同时使用聚合函数 [danger] 错误写法： select ybdm,sum(zyts) zyts, sum(case when c.ypbz in (1,2,3) then xmje else 0 end) yf from ZY_BRJSK a (nolock),ZY_BRJSMXK b (nolock),YY_SFDXMK c (nolock) where a.jsrq between @ksrq and @jsrq+’24’ and a.ybjszt=2 and a.jlzt in (0,1,2) and a.xh=b.jsxh and b.dxmdm=c.id group by ybdm [success] 正确写法： select * into #brjsk from ZY_BRJSK a (nolock) where a.jsrq between @ksrq and @jsrq+’24’ and a.ybjszt=2 and a.jlzt in (0,1,2) create index idx_brjsk_xh on #brjsk(xh) select ybdm, convert(numeric(6,1),0) zyts, sum(case when c.ypbz in (1,2,3) then xmje else 0 end) yf into #temp from #brjsk a (nolock),ZY_BRJSMXK b (nolock),YY_SFDXMK c (nolock) where a.xh=b.jsxh and b.dxmdm=c.id group by ybdm update #temp set zyts=b.zyts from #brjsk a, (select ybdm ,sum(zyts) zyts from #brjsk group by ybdm) b where a.ybdm=b.ybdm select * from #temp 7）占比的写法 [danger] 错误写法： select ybdm,sum(case when c.ypbz in (1,2,3) then xmje else 0 end) yf , sum(xmje) zje into #temp from ZY_BRJSK a (nolock),ZY_BRJSMXK b (nolock),YY_SFDXMK c (nolock) where a.jsrq between @ksrq and @jsrq+'24' and a.ybjszt=2 and a.jlzt in (0,1,2) and a.xh=b.jsxh and b.dxmdm=c.id group by ybdm select ybdm,(zje-yf)/zje*100 治疗费占比,yf/zje*100 药占比 from #temp [success] 正确写法： select ybdm,sum(case when c.ypbz in (1,2,3) then xmje else 0 end) yf , sum(xmje) zje into #temp from ZY_BRJSK a (nolock),ZY_BRJSMXK b (nolock),YY_SFDXMK c (nolock) where a.jsrq between @ksrq and @jsrq+'24' and a.ybjszt=2 and a.jlzt in (0,1,2) and a.xh=b.jsxh and b.dxmdm=c.id group by ybdm select ybdm, case when zje =0 then 0 else convert(numeric(6,2),(zje-yf)/zje*100) end 治疗占比, case when zje =0 then 0 else convert(numeric(6,2), yf/zje*100) end 药占比 from #temp 8）同一参数如何实现取全部或唯一值 以药房代码为例： (@yfdm='-1' or yfdm=@yfdm) 9）如何写动态报表 一般动态输出大项目、核算项目等才需要使用动态语句： exec(@sqlstr) --①@sqlstr 为字符类型 --②定义大项目、核算项目等 ……… declare cs_sfdxm cursor for select id,name from YY_SFDXMK order by id for read only select @sqltitle='',@sqlstr4='', @sqltitle='',sqlsum='' open cs_sfdxm fetch cs_sfdxm into @dxmdm,@dxmmc while @@fetch_status=0 begin --表结构 select @sqlstr=@sqlstr+'id'+@dxmdm+' numeric(12,2) default 0,' --大项目、核算项目的合计 select @sqlstr4=@sqlstr4+'id'+@dxmdm+'+' --输出中文名称 select @sqltitle=@sqltitle+'id'+@dxmdm+' \"'+@dxmmc+'\",' --每栏求合计 select @sqlsum=@sqlsum+'sum(id'+@dxmdm+'),' fetch cs_sfdxm into @dxmdm,@dxmmc end close cs_sfdxm deallocate cs_sfdxm --③@sqlstr中不能使用转换函数，必须转换时只能用游标 ……… declare cs_dxmhz cursor for select ksdm,xmdm,xmje from #dxmhztmp for read only declare @ksdm ut_ksdm,@xmdm ut_kmdm, @xmje numeric(12,2),@xmje1 varchar(16) open cs_dxmhz fetch cs_dxmhz into @ksdm,@xmdm,@xmje while @@fetch_status=0 begin select @xmje1=convert(varchar(16),@xmje) exec('update '+@tablename+' set id'+@xmdm+'='+@xmje1+' where ksdm=\"'+@ksdm+'\"') fetch cs_dxmhz into @ksdm,@xmdm,@xmje end close cs_dxmhz deallocate cs_dxmhz 10）报表输出的内容 临时表应该建立合适的索引 输出的栏目应该用中文 所有的参数必须都输出 保证小计/合计显示在合适的位置。建议最后按代码排序。 11）关于日期 [danger] 错误写法一: create proc usp_test @ksrq ut_rq8, @jsrq ut_rq8 as select @ksrq=@ksrq+\"00:00:00\",@jsrq=@jsrq+\"24:00:00\" select * from VW_MZBRJSK (nolock) where sfrq between @ksrq and @jsrq and ybjszt=2 and jlzt in (0,1,2) [danger] 错误写法二: create proc usp_test @ksrq ut_rq16, @jsrq ut_rq16 as select * from VW_MZBRJSK (nolock) where sfrq between @ksrq and @jsrq+\"24\" and ybjszt=2 and jlzt in (0,1,2) [success] 正确写法: create proc usp_test @ksrq ut_rq8, @jsrq ut_rq8 as select * from VW_MZBRJSK (nolock) where sfrq between @ksrq and @jsrq+\"24\" and ybjszt=2 and jlzt in (0,1,2) [warning] 注意:日期类型: ut_rq8 8位字符 格式：yyyymmdd ut_rq16 16位字符 格式：yyyymmddhh:nn:ss 12）关于纵表转横表的写法 select a.sjh,a.cardno,a.hzxm,xjje,zpje,srje,yhje,zje,qkbz,qkje, convert(numeric(12,2),sum(case when b.lx in ('01') then je else 0 end)) dnzhzf, convert(numeric(12,2),sum(case when b.lx in ('02','04','07') then je else 0 end)) lnzhzf, convert(numeric(12,2),sum(case when b.lx in ('03','05','08') then je else 0 end)) xjzf1, convert(numeric(12,2),sum(case when b.lx in ('06') then je else 0 end)) tczf, convert(numeric(12,2),sum(case when b.lx in ('09') then je else 0 end)) fjzf into #temp1 from VW_MZBRJSK a (nolock),VW_MZJEMXK b (nolock) where a.sfrq between '20031201' and '2003120124' and a.ybjszt=2 and a.jlzt in (0,1,2) and a.sjh=b.jssjh group by a.sjh,a.cardno,a.hzxm,xjje,zpje,srje,yhje,zje,qkbz,qkje select a.cardno,a.hzxm, convert(numeric(12,2),sum(dnzhzf)) 当年账户支付, convert(numeric(12,2),sum(lnzhzf)) 历年账户支付, convert(numeric(12,2),sum(xjzf1)) 现金支付1, convert(numeric(12,2),sum(tczf)) 统筹支付, convert(numeric(12,2),sum(fjzf)) 附加支付, convert(numeric(12,2),sum(xjje)) 现金支付, convert(numeric(12,2),sum(zpje)) 支票支付, convert(numeric(12,2),sum(case when qkbz=1 then qkje else 0 end)) 其他记帐, convert(numeric(12,2),sum(case when qkbz=2 then qkje else 0 end)) 欠款, convert(numeric(12,2),sum(case when qkbz=3 then qkje else 0 end)) 充值卡支付, convert(numeric(12,2),sum(srje)) 舍入, convert(numeric(12,2),sum(yhje)) 优惠, convert(numeric(12,2),sum(zje)) 总金额 into #temp2 from #temp1 a group by a.cardno,a.hzxm [warning] 注意： 1.纵表转横表的写法 2.要了解#temp1中为何加sjh 3.现金支付1与现金支付的区别 4.平衡关系：总金额+舍入=当年账户支付+历年账户支付+统筹支付+附加支付+现金支付+支票支付+其他记帐+欠款+充值卡支付+优惠 5.为何分步求和？ 13）报表栏目的合并 方法一：通过关键字段关联连接，适合一个表的记录完全包含另一表的记录 方法二：生成一个全部字段表，再用另一表中的字段替换，适合一个表的记录完全包含另一表的记录。 方法三：先建一临时表（全部字段），分别插入对应字段，再求和。 select a.keyfield,a.field1,b.field2 from #temp1 a,#temp2 b where a.keyfield*=b.keyfield "},"Winning_Kill_One/常用报表的取数方法.html":{"url":"Winning_Kill_One/常用报表的取数方法.html","title":"常用报表的取数方法","keywords":"","body":"三、常用报表的取数方法 1）按执行科室统计门诊收费总金额等 select a.yfdm,sum(b.ypsl*b.ts*b.cfts*b.ylsj/b.ykxs) zje from VW_MZCFK a (nolock), VW_MZCFMXK b (nolock) ,VW_MZBRJSK c (nolock) where c.sfrq between @ksrq and @jsrq+’24’ and c.ybjszt=2 and c.jlzt in (0,1,2) and ghsfbz=1 --收费 and c.sjh=a.jssjh and a.xh=b.cfxh group by a.yfm 2）按医生科室统计门诊收费总金额、发票数等 select ksdm,convert(numeric(14,2),sum(zje)) zje, sum(case when a.jlzt in (0,1) then 1 else 0 end) fpzs --不按处方打发票 from VW_MZBRJSK (nolock) Where sfrq between @ksrq and @jsrq+ '24' and ybjszt=2 and jlzt in (0,1,2) and ghsfbz=1 --收费 Group by ksdm 3）按医生科室统计门诊收费总金额，药费 select a.ksdm , convert(numeric(14,2),sum(case when c.ypbz in (1,2,3) then b.xmje else 0 end)) ypje, convert(numeric(14,2),sum(b.xmje)) zje from VW_MZBRJSK a(nolock),VW_MZBRJSMXK b(nolock),YY_SFDXMK c Where sfrq between @ksrq and @jsrq+ '24' and a.ybjszt=2 and a.jlzt in (0,1,2) and ghsfbz=1 --收费 and a.sjh=b.jssjh and b.dxmdm=c.id group by a.ksdm 4）按收费大项目统计总金额 select b.dxmdm, convert(numeric(14,2),sum(b.xmje)) zje, convert(numeric(14,2),sum(b.zfje)) zfje from VW_MZBRJSK a(nolock),VW_MZBRJSMXK b(nolock) Where a.sfrq between @ksrq and @jsrq+ '24' and a.ybjszt=2 and a.jlzt in (0,1,2) and ghsfbz=1 --收费 and a.sjh=b.jssjh group by b.dxmdm 5）按费用发生时病人所在科室统计住院结帐病人费用 select b.ksdm, sum(case when a.jlzt in (0,2) then b.zje else –b.zje end) zje, sum( case when c.ypbz in (1,2,3) and a.jlzt in (0,2) then b.zje when c.ypbz in (1,2,3) and a.jlzt in (1) then -b.zje else 0 end) ypje, count(distinct a.syxh) jzrs from ZY_BRJSK a (nolock),ZY_BRFYMXK b (nolock),YY_SFDXMK c (nolock) where a.jsrq between @ksrq and @jsrq+'24' and a.ybjszt=2 and a.jlzt in (0,1,2) and a.syxh=b.syxh and b.zxrq between a.ksrq and a.jzrq and b.dxmdm=c.id group by b.ksdm --据此计算次均费用, 日均费用，均住院天，人均药费，药占比例 6）按病人当前所在科室统计住院结帐病人费用 select b.ksdm, sum(a.zje) zje， count(distinct a.syxh) jzrs，sum(a.zyts) zyts from ZY_BRJSK a (nolock),ZY_BRSYK b (nolock) where a.jsrq between @ksrq and @jsrq+'24' and a.ybjszt=2 and a.jlzt in (0,1,2) and a.syxh=b.syxh group by b.ksdm 7）出院人数和住院天数 select count(distinct a.syxh) jzrs sum(a.zyts) zyts from ZY_BRJSK a (nolock) where a.jsrq between @ksrq and @jsrq+'24' and a.ybjszt=2 and a.jlzt in (0,1,2) and jszt=2 --出院结算 8）住院发票补打 select a.blh \"病历号\",a.cardno \"卡号\",a.hzxm \"病人姓名\",a.sex \"性别\",fph \"发票号\", e.ybsm \"医保类型\",b.dwmc \"单位\", substring(a.ryrq,1,4)+'.'+substring(a.ryrq,5,2)+'.'+substring(a.ryrq,7,2)+' ' +substring(a.ryrq,9,8)+(case when substring(a.ryrq,9,2)='12' then 'PM' else 'AM' end) \"出院日期\", c.zyts \"住院天数\",d.name \"病区名称\",g.name \"科室\",a.cwdm \"床位\",c.zje \"总费用\", c.zje-c.zfje+c.srje \"记帐金额\",c.zfje-c.srje \"自己负担\",c.zfyje \"自费部分\", c.qfje \"欠费\",c.zje-c.zfyje \"可报部分\", substring(c.jsrq,1,4)+'.'+substring(c.jsrq,5,2)+'.'+substring(c.jsrq,7,2)+' '+substring(c.jsrq,9,8)+ (case when substring(c.jsrq,9,2) 9）全院药品消耗统计 --药库 select a.cd_idm,sum(a.cksl) ypsl, sum(a.ckje_ls) lsje, sum(a.ckje_pf) pfje from YK_YPTZMXK a (nolock),YK_YPCDMLK b (nolock) where a.cd_idm=b.idm and a.czrq between @ksrq and @jsrq+'24' and charindex(b.yplh,@yplh)>0 and a.czdm in ('02','04','08','16','21')-- 报损,盘亏,退货,调亏,科室发药 group by a.cd_idm union all --药房 select a.cd_idm,sum(a.cksl) ypsl, sum(a.ckje_ls) lsje,sum(a.ckje_pf) pfje from YF_YPTZMXK a (nolock),YK_YPCDMLK b (nolock) where a.cd_idm=b.idm and a.czrq between @ksrq and @jsrq+'24' and charindex(b.yplh,@yplh)>0 and a.czdm in ('02','04','08','09','11','13','16','21') --报损,盘亏,退货,门诊发药,住院发药,出院带药,调亏,科室发药 group by a.cd_idm 10）药库药品出库统计 select snull(c.cjmc,'无') \"厂家名称\",b.ypdm \"药品代码\",b.ypmc \"药品名称\",b.ypgg \"规格\", max(c.ylsj) \"零售价\", sum(b.cksl/b.ykxs) \"数量\",c.ykdw \"单位\", sum(b.cksl*b.ylsj/b.ykxs) \"零售金额\", sum(-b.jxce) \"进销差额\" from YK_YPCKZD a (nolock), YK_YPCKMX b (nolock), YK_YPCDMLK c (nolock) where a.yfrq between @ksrq and @jsrq+'24' and a.xh=b.zd_xh and b.cd_idm=c.idm and a.jzbz>0 and a.jlzt=0 and a.qrbz=1 group by c.cjmc,b.ypdm,b.ypmc,b.ypgg,c.ykdw union select isnull(c.cjmc,'无') \"厂家名称\",b.ypdm \"药品代码\",b.ypmc \"药品名称\", b.ypgg \"规格\",max(c.ylsj) \"零售价\", sum(b.cksl/b.ykxs) \"数量\", c.ykdw \"单位\",sum(b.cksl*b.ylsj/b.ykxs) \"零售金额\",sum(-b.jxce) \"进销差额\" from YK_KSFYZD a (nolock), YK_KSFYMX b (nolock), YK_YPCDMLK c (nolock) where a.jzrq between @ksrq and @jsrq+'24' and a.xh=b.zd_xh and b.cd_idm=c.idm and a.jzbz>0 and a.jlzt=0 group by c.cjmc,b.ypdm,b.ypmc,b.ypgg,c.ylsj,c.ykdw union select isnull(c.cjmc,'无') \"厂家名称\",b.ypdm \"药品代码\",b.ypmc \"药品名称\",b.ypgg \"规格\", max(c.ylsj) \"零售价\",sum(-b.tksl/b.ykxs) \"数量\",c.ykdw \"单位\", sum(-b.tksl*b.ylsj/b.ykxs) \"零售金额\",sum(b.jxce) \"进销差额\" from YF_YFTKZD a (nolock), YF_YFTKMX b (nolock), YK_YPCDMLK c (nolock) where a.ykrq between @ksrq and @jsrq+'24' and a.xh=b.zd_xh and b.cd_idm=c.idm and a.jzbz>0 and a.jlzt=0 and a.qrbz=1 group by c.cjmc,b.ypdm,b.ypmc,b.ypgg,c.ykdw 11．药库药品进货统计 select c.cjmc ,b.ypdm ,b.ypmc ,b.ypgg ,c.ykdw ,max(c.ylsj) ylsj, sum(b.rksl/b.ykxs) ypsl,sum(b.rksl*b.ylsj/b.ykxs) sum_lsje, sum(b.jjje) sum_jjje,sum(b.jxce) sum_jxce from YK_YPRKZD a(nolock),YK_YPRKMX b(nolock),YK_YPCDMLK c(nolock) where a.rkrq between @ksrq and @jsrq+'24' and a.xh=b.zd_xh and b.cd_idm=c.idm and a.jzbz>0 and a.gzbz<>1 and a.rkdm <> '02' group by c.cjmc,b.ypdm,b.ypmc,b.ypgg,c.ykdw -- 正常入库和已冲正的 union select c.cjmc ,b.ypdm ,b.ypmc ,b.ypgg,c.ykdw ,max(c.ylsj) ylsj, sum(b.rksl/b.ykxs) ypsl,sum(b.rksl*b.ylsj/b.ykxs) sum_lsje, sum(b.jjje) sum_jjje,sum(b.jxce) sum_jxce from YK_YPRKZD a(nolock),YK_YPRKMX b(nolock),YK_YPCDMLK c(nolock) where a.rkrq between @ksrq and @jsrq+'24' and a.xh=b.zd_xh and b.cd_idm=c.idm and a.jzbz>0 and ((a.rkdm = '02' and a.dpbz=0) or (a.rkdm='00' and a.dpbz=1)) group by c.cjmc,b.ypdm,b.ypmc,b.ypgg,c.ykdw -- 挂帐入库不包括已冲证 union select c.cjmc ,b.ypdm ,b.ypmc ,b.ypgg ,c.ykdw,max(c.ylsj),-sum(b.thsl/b.ykxs), -sum(b.thsl*b.ylsj/b.ykxs) sum_lsje, -sum(b.thje) sum_jjje,sum(b.jxce) sum_jxce from YK_YPTHZD a(nolock),YK_YPTHMX b(nolock),YK_YPCDMLK c(nolock) where a.jzrq between @ksrq and @jsrq and a.xh=b.zd_xh and b.cd_idm=c.idm and a.jzbz>0 group by c.cjmc,b.ypdm,b.ypmc,b.ypgg,c.ykdw 12）住院医生开药统计 select a.ysdm,c.name,a.ksdm,e.name,a.ypmc,a.ypgg,avg(a.ypdj), sum(a.ypsl/a.dwxs),a.ypdw,sum(a.zje),1 from ZY_BRFYMXK a (nolock),YY_ZGBMK c (nolock),YK_YPCDMLK d(nolock),YY_KSBMK e where a.zxrq between @ksrq and @jsrq+'24' and a.idm=d.idm and a.ysdm=c.id and d.py like @py and a.ksdm = e.id group by a.ypmc,a.ypdw,a.ypgg,a.ksdm,e.name,a.ysdm,c.name 13）门诊病人用药统计 select a.yfdm ,b.ypdm, b.ypmc,b.ypgg, b.ypdw, b.ylsj*b.dwxs/b.ykxs ypdj, sum(b.ypsl*b.cfts/b.dwxs) ypsl,sum(b.ylsj*b.ypsl*b.cfts/b.ykxs) zje from VW_MZFYZD a(nolock),VW_MZFYMX b(nolock) where a.fyrq between @ksrq and @jsrq+'24' and a.jlzt=0 and a.jzbz in (1,2) and a.xh=b.fyxh group by a.yfdm ,b.ypdm, b.ypmc,b.ypgg, b.ypdw, b.ylsj,b.dwxs,b.ykxs 14）住院病人用药统计 select a.yfdm ,b.ypdm, b.ypmc,b.ypgg, b.ypdw, b.ylsj*b.dwxs/b.ykxs ypdj, sum(b.ypsl*isnull(b.cfts,1)/b.dwxs) ypsl, sum(b.ylsj*b.ypsl*isnull(b.cfts,1)/b.ykxs,2) zje from VW_ZYFYZD a (nolock),VW_ZYFYMX b (nolock) where a.fyrq between @ksrq and @jsrq+'24' and a.jzbz in (1,2) and a.xh=b.fyxh group by a.yfdm ,b.ypdm, b.ypmc,b.ypgg, b.ypdw, b.ylsj,b.dwxs,b.ykxs 15）门诊药房收方工作量统计 select a.yfdm,sfczry, count(distinct b.xh) cfs, sum(c.ypsl*c.ts*c.cfts*c.ylsj/c.ykxs) je from VW_MZFYZD a (nolock),VW_MZCFK b (nolock),VW_MZCFMXK c (nolock) where a.sfrq between @ksrq and @jsrq+'24' and a.jlzt=0 and a.jzbz in (1,2) and a.cfxh=b.xh and c.cfxh=b.xh group by a.yfdm,sfczry 16）门诊发药工作量统计 select a.yfdm,fyczry, count(distinct b.xh) cfs, sum(c.ypsl*c.ts*c.cfts*c.ylsj/c.ykxs) je from VW_MZFYZD a (nolock),VW_MZCFK b (nolock),VW_MZCFMXK c (nolock) where a.sfrq between @ksrq and @jsrq+'24' and a.jlzt=0 and a.jzbz in (1,2) and a.cfxh=b.xh and c.cfxh=b.xh group by a.yfdm,fyczyh 17）按住院操作员统计押金和收退款 select a.czyh,a.czym,sum(convert(numeric(12,2),jje-dje)) yjj from ZYB_BRYJK a (nolock) where a.lrrq between @ksrq and @jsrq+'24' and a.czlb in (0,1,2,6) --预交金、收付金额 and a.zffs in ('1','3') --现金、财退现金 group by a.czyh,a.czym "},"Winning_Kill_Two/技术手册第二册.html":{"url":"Winning_Kill_Two/技术手册第二册.html","title":"技术手册第二册","keywords":"","body":"技术手册第二册 主要讲的业务流程、数据流向"},"Winning_Kill_Two/常用表介绍.html":{"url":"Winning_Kill_Two/常用表介绍.html","title":"第一篇 常用表介绍","keywords":"","body":""},"Winning_Kill_Two/挂号.html":{"url":"Winning_Kill_Two/挂号.html","title":"第一节 挂号","keywords":"","body":"挂号 挂号业务流程 挂号数据关系 重要存储过程 --基本信息登记 usp_gh_jbxxdj --获取挂号排班 usp_gh_getkszj --挂号登记 usp_gh_ghdj usp_gh_ghdj_ex2 "},"Winning_Kill_Two/收费.html":{"url":"Winning_Kill_Two/收费.html","title":"第二节 收费","keywords":"","body":"收费 收费业务流程 收费数据关系 重要存储过程 --收费 usp_sf_sfcl usp_sf_sfcl_ex2 --退费 usp_sf_bftf usp_sf_bftf_ex2 "},"Diy_Skill/SQL必知必会.html":{"url":"Diy_Skill/SQL必知必会.html","title":"SQL须知须会","keywords":"","body":""},"Diy_Skill/SQL执行顺序.html":{"url":"Diy_Skill/SQL执行顺序.html","title":"SQL执行顺序","keywords":"","body":"SQL Server 查询处理中的各个阶段(SQL执行顺序) SQL 不同于与其他编程语言的最明显特征是处理代码的顺序。在大数编程语言中，代码按编码顺序被处理，但是在SQL语言中，第一个被处理的子句是FROM子句，尽管SELECT语句第一个出现，但是几乎总是最后被处理。 简单说明 from:需要从哪个数据表检索数据 where:过滤表中数据的条件 group by:如何将上面过滤出的数据分组 having:对上面已经分组的数据进行过滤的条件 select:查看结果集中的哪个列，或列的计算结果 order by:按照什么样的顺序来查看返回的数据 详细概括 SQL Server每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用者（客户端应用程序或者外部查询）不可用。只是最后一步生成的表才会返回 给调用者。如果没有在查询中指定某一子句，将跳过相应的步骤。下面是对应用于SQL server 2000和SQL Server 2005的各个逻辑步骤的简单描述。 (8)SELECT (9)DISTINCT (11) (1)FROM [left_table] (3) JOIN (2) ON (4)WHERE (5)GROUP BY (6)WITH (7)HAVING (10)ORDER BY 逻辑查询处理阶段简介 1、FROM：对FROM子句中的前两个表执行笛卡尔积（Cartesianproduct)(交叉联接），生成虚拟表VT1 2、ON：对VT1应用ON筛选器。只有那些使为真的行才被插入VT2。 3、OUTER(JOIN)：如 果指定了OUTER JOIN（相对于CROSS JOIN 或(INNERJOIN),保留表（preservedtable：左外部联接把左表标记为保留表，右外部联接把右表标记为保留表，完全外部联接把两个表都标记为保留表）中未找到匹配的行将作为外部行添加到VT2,生成VT3.如果FROM子句包含两个以上的表，则对上一个联接生成的结果表和下一个表重复执行步骤1到步骤3，直到处理完所有的表为止。 4、WHERE：对VT3应用WHERE筛选器。只有使为true的行才被插入VT4. 5、GROUP BY：按GROUP BY子句中的列列表对VT4中的行分组，生成VT5. 6、CUBE|ROLLUP：把超组(Suppergroups)插入VT5,生成VT6. 7、HAVING：对VT6应用HAVING筛选器。只有使为true的组才会被插入VT7. 8、SELECT：处理SELECT列表，产生VT8. 9、DISTINCT：将重复的行从VT8中移除，产生VT9. 10、ORDER BY：将VT9中的行按 ORDER BY 子句中的列列表排序，生成游标（VC10). 11、TOP：从VC10的开始处选择指定数量或比例的行，生成表VT11,并返回调用者。 [warning] Tips 提高 GROUP BY 语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉。 即在 GROUP BY 前使用WHERE来过虑，而尽量避免GROUP BY后再HAVING过滤。 避免使用 HAVING 子句, HAVING 只会在检索出所有记录之后才对结果集进行过滤。这个处理需要排序,总计等操作. SELECT 子句--少用 * 号，尽量取字段名称。 ORDER BY 子句--执行顺序为从左到右排序,很耗资源 "},"Winning_Kill_Two/门诊发药.html":{"url":"Winning_Kill_Two/门诊发药.html","title":"第二节 门诊发药","keywords":"","body":"门诊发药 收费业务流程 门诊发药数据关系 "}}